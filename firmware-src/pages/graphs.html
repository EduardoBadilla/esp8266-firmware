<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
	<title>Graphs</title>
	<style>
text.label-text {
	fill: black;
}
.line {
	fill: none;
	stroke-width: 1.6px;
}
.axis-x path.domain {
	stroke: rgba(0.8, 0.8, 0.8, 0.5);
}
.axis-y path.domain {
	stroke-width: 1.6px;
}
text.label-left {
	transform: rotate(-90deg) translate(0, 1.5em);
}
text.label-right {
	transform: rotate(90deg) translateY(1.5em);
}
.legend {
	margin-left: 40px;
}
.legend label {
	display: inline-block;
	margin-right: 20px;
	border-top: 2px solid transparent;
}
.legend input[type="checkbox"] {
	vertical-align: middle;
}
	</style>
	<script src="libs.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.4.1/d3.min.js"></script>
	<script>
/*jshint browser: true*/
/*globals d3, ajax, getKey, byId, renderDom*/
var now = function() {
	return Date.now();
};
var colors = [
	'#007e67',
	'#5f47f3',
	'#66ff80',
	'#ff50d6',
	'#1f9200',
	'#a485ff',
	'#b9b100',
	'#3c0068',
	'#fbff84',
	'#003b95',
	'#ff6f11',
	'#0172bc',
	'#8f1e00',
	'#74ffde',
	'#ab004a',
	'#57ceff',
	'#5a0e00',
	'#f9f1ff',
	'#0d002c',
	'#ffa995',
	'#001c1b',
	'#ff74b9',
	'#2d3600',
	'#630046'];

var plot;
var initPlot = function() {
	var data = [];
	var maxTimeRange = 60 * 1000;
	var minTimeRange = 10 * 1000;
	var dirty = true;
	var cutOff = false;

	var margin = {top: 20, right: 40, bot: 30, left: 40};
	var svg = d3.select('svg');
	var width = +svg.attr('width') - margin.left - margin.right;
	var height = +svg.attr('height') - margin.top - margin.bot;
	var g = svg.append('g')
		.attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');

	var scaleX = d3.scaleTime().rangeRound([0, width]);
	var scaleY = d3.scaleLinear().rangeRound([height, 0]);

	var axisX;
	var axisY;
	var sources = [];
	var strkey = function(key) {
		if (!Array.isArray(key)) {
			return key;
		}
		return key.join('.');
	};
	var setSources = function(srcs) {
		sources = srcs.map(function(src, idx) {
			var key = strkey(src.key);
			var line = d3.line()
				.x(function(d) { return scaleX(d.ts); })
				.y(function(d) { return scaleY(d[key]); });

			return {
				idx: idx,
				color: src.color || colors[idx] || 'black',
				left: !!src.left,
				akey: src.key,
				key: key,
				label: src.label,
				visible: true,
				minDomain: src.minDomain,
				line: line
			};
		});

		g.select('path.line').remove();
		sources.forEach(function(src) {
			var lineClass = src.left ? 'line-left' : 'line-right';
			console.log(src.color);
			src.path = g.append('path')
				.attr('stroke', src.color)
				.attr('class', 'line ' + lineClass + ' line-' + src.idx);
		});

		var legend = byId('legend');
		legend.innerHTML = '';
		sources.forEach(function(src) {
			var label = renderDom(['label', {},
				['input', {type: 'checkbox', checked: true}],
				src.label || src.key]);
			var input = label.childNodes[0];
			label.style.borderColor = src.color;
			input.onchange = function() {
				src.visible = input.checked;
				src.path.style('visibility', src.visible ? 'visible' : 'hidden');
				dirty = true;
			};
			legend.appendChild(label);
		});
		dirty = true;
	};

	var lookup = function(obj, key) {
		if (!Array.isArray(key)) {
			return obj[key];
		}
		key.forEach(function(k) {
			obj = obj[k];
		});
		return obj;
	};

	var deriveConfig;
	deriveConfig = function(obj) {
		var measures = [];
		Object.keys(obj).forEach(function(k) {
			var v = obj[k];
			if (typeof v === 'object') {
				deriveConfig(v).forEach(function(m) {
					m.key = [k].concat(m.key);
					measures.push(m);
				});
			} else if (typeof v === 'number') {
				measures.push({
					key: [k]
				});
			} else {
				console.error('ignoring a key inside json', v);
			}
		});
		return measures;
	};

	var feed = function(datum) {
		var ts = now();
		if (sources.length === 0) {
			// hax
			setSources(deriveConfig(datum));
		}
		var d = {ts: ts};
		sources.forEach(function(s) {
			d[s.key] = lookup(datum, s.akey);
		});
		data.push(d);
		dirty = true;
	};

	var cutOld = function() {
		var ts = now();
		var cutTime = ts - maxTimeRange;
		var i;
		for (i = 0; i < data.length - 1; i += 1) {
			if (data[i].ts >= cutTime) {
				break;
			}
		}
		if (i > 1) {
			data = data.slice(i - 1);
			cutOff = true;
			dirty = true;
		}
	};

	var calcExtentX = function() {
		var ts = now();
		var left = d3.min(data, function(d) { return d.ts; });
		if (cutOff || left === undefined) {
			left = ts - maxTimeRange;
		}
		left = Math.min(left, ts - minTimeRange);
		return [left, ts];
	};

	var calcExtentY = function() {
		var domain = [];
		sources.forEach(function(src) {
			if (src.visible) {
				domain = domain.concat(d3.extent(data, function(d) { return d[src.key]; }));
			}
		});
		domain = d3.extent(domain);
		if (isNaN(domain[0]) || isNaN(domain[1])) {
			return [0, 1];
		} else {
			return d3.extent(domain);
		}
	};

	var reset = function() {
		data = [];
		sources.forEach(function(src) {
			src.path.datum([]).attr('d', src.line);
		});
		sources = [];
		dirty = true;
		cutOff = false;
	};

	var redrawAxisX = function() {
		if (axisX) {
			axisX.remove();
		}
		axisX = g.append('g')
			.attr('class', 'axis-x')
				.attr('transform', 'translate(0,' + height + ')')
				.call(d3.axisBottom(scaleX).tickArguments([undefined, '%H:%M:%S']));
	};

	var redrawAxisY = function() {
		if (axisY) {
			axisY.remove();
		}
		axisY = g.append('g')
			.attr('class', 'axis-y')
				.call(d3.axisLeft(scaleY));
	};

	var redraw = function() {
		cutOld();
		scaleX.domain(calcExtentX());
		redrawAxisX();

		if (dirty) {
			scaleY.domain(calcExtentY());
			redrawAxisY();
		}

		sources.forEach(function(src) {
			if (src.visible) {
				src.path.datum(data).attr('d', src.line);
			}
		});

		dirty = false;
	};

	return {
		reset: reset,
		setSources: setSources,
		feed: feed,
		redraw: redraw
	};
};

var dataSource;
var initDataSource = function(opts) {
	var interval = Math.max(opts.interval || 1000, 200);

	var running = false;
	var requestInProgress = false;
	var sink;
	var loop = function() {
		if (requestInProgress || !running) {
			return;
		}
		requestInProgress = true;
		ajax(opts.verb, opts.url, opts.params, getKey(), function(xhr) {
			if (!running) {
				return;
			}
			requestInProgress = false;
			if (xhr.status < 200 || xhr.status > 299) {
				console.error('error getting data:', xhr);
				return;
			}
			var datum;
			try {
				datum = JSON.parse(xhr.responseText);
				if (typeof opts.map === 'function') {
					datum = opts.map(datum);
				}
			} catch(e) {
				console.error('error during data transformation:', e);
			}

			sink(datum);
		});
	};

	var intervalId;
	var stop = function() {
		if (!running) {
			return;
		}
		running = false;
		requestInProgress = false;
		clearInterval(intervalId);
		sink = null;
	};

	var start = function(target) {
		if (typeof target !== 'function') {
			throw new Error('expected function as an argument');
		}
		if (running) {
			stop();
		}
		sink = target;
		intervalId = setInterval(loop, interval);
		running = true;
	};

	return {
		start: start,
		stop: stop
	};
};

var renderLoop = (function() {
	var raf = window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				return window.setTimeout(callback, 16);
			};
	var caf = window.cancelAnimationFrame ||
		window.webkitCancelAnimationFrame ||
		window.mozCancelAnimationFrame ||
		window.oCancelAnimationFrame ||
		window.msCancelAnimationFrame ||
		function(id) {
			window.clearTimeout(id);
		};

	var running = false;
	var rafId;
	var callback;
	var loop;
	loop = function() {
		if (!running) {
			return;
		}

		try {
			callback();
		} catch(e) {
			console.error(e);
		}
		rafId = raf(loop);
	};

	var stop = function() {
		if (!running) {
			return;
		}
		running = false;
		caf(rafId);
	};

	var start = function(cb) {
		if (typeof cb !== 'function') {
			throw new Error('expected function as an argument');
		}
		if (running) {
			stop();
		}
		running = true;
		callback = cb;
		loop();
	};

	var isRunning = function() {
		return running;
	};

	return {
		stop: stop,
		start: start,
		isRunning: isRunning
	};
}());

window.onload = function init() {
	plot = initPlot();
	plot.redraw();
};

var selectSource = function(name) {
	if (dataSource) {
		dataSource.stop();
		dataSource = null;
	}
	plot.reset();
	renderLoop.stop();
	if (name === '') {
		return;
	}
	dataSource = initDataSource({
		verb: 'GET',
		url: '/api/devices/' + name + '/read',
		params: null
	});
	//plot.setSources(cfg.plotConfig);
	dataSource.start(plot.feed);
	renderLoop.start(plot.redraw);
};
	</script>
</head>
<body>
<div class="header">
	<a href="./help.html"><div class="devecihive-logo-text"></div></a>
	<div class="key-box">
		<label for="accesskey">AccesKey: </label>
		<input class="input-accesskey input-data" type="password" id="accesskey">
	</div>
</div>
<div class="content">
	<div class="form-block">
		<div class="description">This sample page plots readouts over time.</div>
		<div class="group-box">
			<select onchange="selectSource(this.value)">
				<option value="">Select data source to plot</option>
				<option value="mpu6050">MPU6050</option>
			</select>
			<svg width="1000" height="480"></svg>
			<div id="legend" class="legend"></div>
		</div>
		<div class="output-status" id="output"></div>
	</div>
</div>
</body>
</html>